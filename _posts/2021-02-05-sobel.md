---
layout: post
title:  "Sobel 邊緣偵測演算法"
---

又稱 Sobel 算子（operator），是一離散差分算子，使用兩個 $$3\times 3$$ kernel 對圖片做卷積，求得兩個不同方向的梯度，梯度大者為邊緣。

## Implement:

令原始圖片為 $$A$$， $$ f(x, y) $$ 為 $$A$$ 在 $$(x, y)$$ 座標上的灰階值，
則該位置梯度為

$$
| \nabla f(x, y) | = | G_x | + | G_y | = \begin{bmatrix} 1 & 0 & -1 \\ 2 & 0 & -2 \\ 1 & 0 & -1 \end{bmatrix} * A +
                              \begin{bmatrix} 1 & 2 & 1 \\ 0 & 0 & 0 \\ -1 & -2 & -1 \end{bmatrix} * A
$$

使用`OpenCV`內建函數實作。
```c++=
/**
 * @src: 輸入灰階圖
 * @dst: 與原圖大小一樣，數值為垂直和水平方向梯度
 * @ksize: ksernel size
 * @scale: 將梯度放大的係數
 * @delta: 將梯度增加的數值
 */
void sobel(const cv::Mat& src, cv::Mat& dst, int ksize, int scale, int delta)
{
    int ddepth = -1;
    cv::Mat grad_x, grad_y;
    cv::Mat abs_grad_x, abs_grad_y;
    // ddepth: 數據類型， 設定 -1 與輸入圖片一致
    cv::Sobel(src, grad_x, ddepth, 1, 0, ksize, scale, delta, cv::BORDER_DEFAULT);
    cv::Sobel(src, grad_y, ddepth, 0, 1, ksize, scale, delta, cv::BORDER_DEFAULT);

    // 防止梯度大小超出 [0, 255]，做正規化
    cv::convertScaleAbs(grad_x, abs_grad_x);
    cv::convertScaleAbs(grad_y, abs_grad_y);

    cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst);
}
```

## Result:

<img src="/assets/images/2021-02-05-sobel/result.png" width="1300">

## References:

[完整程式碼](https://github.com/jysh1214/CVResearchCode/blob/master/src/sobel.hpp)

[利用cv2.Sobel()计算图像梯度的细节讲解](https://blog.csdn.net/weixin_42216109/article/details/89642914)
