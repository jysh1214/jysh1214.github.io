---
layout: post
title:  "OpenCV gemm 函數"
---
`gemm`是`generalized matrix multiplication`的縮寫，是常見的線性代數算法。
實現了以下功能：

$$
C = \alpha \cdot A \cdot B + \beta \cdot D
$$

單純實現矩陣乘法的話，將 $$\alpha$$ 設為 $$1.0$$ ， $$\beta$$ 設為 $$0.0$$ 。

使用`OpenCV`內建的`gemm`函數實現矩陣相乘。
```c++=
#include <opencv2/core.hpp>
#include <iostream>

int main()
{
    float arr_a[3][3] = {
        {2, 2, 2},
        {1, 1, 1},
        {1, 1, 1}
    };
    float arr_b[3][3] = {
        {1, 1, 1},
        {2, 1, 1},
        {1, 1, 1}
    };
    cv::Mat matrix_a{3, 3, CV_32F, arr_a};
    cv::Mat matrix_b{3, 3, CV_32F, arr_b};

    cv::Mat matrix_c;
    cv::gemm(matrix_a, matrix_b, 1.0, cv::Mat(), 0.0, matrix_c);
    std::cout << matrix_c << "\n";

    return 0;
}
```
Rsult:
```bash=
[8, 6, 6;
 4, 3, 3;
 4, 3, 3]
```

使用`CUDA`來加速運算。
```c++=
#include <opencv2/core.hpp>
#include <opencv2/cudaarithm.hpp>
#include <iostream>

int main()
{
    float arr_a[3][3] = {
        {2, 2, 2},
        {1, 1, 1},
        {1, 1, 1}
    };
    float arr_b[3][3] = {
        {1, 1, 1},
        {2, 1, 1},
        {1, 1, 1}
    };
    cv::Mat matrix_a{3, 3, CV_32F, arr_a};
    cv::Mat matrix_b{3, 3, CV_32F, arr_b};

    cv::Mat matrix_c;
    // cv::gemm(matrix_a, matrix_b, 1.0, cv::Mat(), 0.0, matrix_c);
    cv::cuda::gemm(matrix_a, matrix_b, 1.0, cv::Mat(), 0.0, matrix_c);
    std::cout << matrix_c << "\n";

    return 0;
```
Rsult:
```bash=
[8, 6, 6;
 4, 3, 3;
 4, 3, 3]
```

### 效能比較

實作 $$ 1000 \sim 10000 $$ 階矩陣相乘，比較`CPU`與`GPU`效能差異。
```c++=
#include <opencv2/core.hpp>
#include <opencv2/cudaarithm.hpp>

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int N = 1000;
    double cpu_time[10], gpu_time[10];
    printf("matrix size, CPU, GPU\n");

    for (int i = 0; i < 10; i++) {
        clock_t start, end;
        cv::Mat matrix_a{N, N, CV_32F, cv::Scalar(1.0)};
        cv::Mat matrix_b{N, N, CV_32F, cv::Scalar(1.0)};
        cv::Mat matrix_c, dst;

        start = clock();
        cv::gemm(matrix_a, matrix_b, 1.0, matrix_c, 0.0, dst);
        end = clock();

        cpu_time[i] = ((double)(end - start));

        start = clock();
        cv::cuda::gemm(matrix_a, matrix_b, 1.0, matrix_c, 0.0, dst);
        end = clock();

        gpu_time[i] = ((double)(end - start));

        printf("%d, %lf, %lf\n", N, cpu_time[i], gpu_time[i]);

        N += 1000;
    }

    return 0;
}
```

<center><img src="/assets/images/2021-02-15-gemm/time.png" width="500"></center>

## References:

1. [OpenCV gemm](https://docs.opencv.org/master/d9/d88/group__cudaarithm__arithm.html)
2. [C program for Time Complexity plot of Bubble, Insertion and Selection Sort using Gnuplot](https://www.geeksforgeeks.org/c-program-for-time-complexity-plot-of-bubble-insertion-and-selection-sort-using-gnuplot/)
